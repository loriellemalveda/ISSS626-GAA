---
title: "Hands-on Exercise 9: Geographical Segmentation with Spatially Constrained Clustering Techniques"
author: "Lorielle Malveda"
date: "September 25, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
---

# 1. OVERVIEW

In this exercise, we are going to delineate homogeneous regions by using geographically referenced multivariate data.

**There are two major analysis:**

-   **hierarchical cluster analysis; and**

-   **spatially constrained cluster analysis.**

### LEARNING OUTCOME

By the end of this hands-on exercise, you will able:

-   to convert GIS polygon data into *R’s simple feature data.frame* by using appropriate functions of ***sf*** package of R;

-   to convert simple feature data.frame into *R’s SpatialPolygonDataFrame* object by using appropriate ***sf*** of package of R;

-   to perform cluster analysis by using `hclust()` of Base R;

-   to perform spatially constrained cluster analysis using [`skater()`]{.underline} of Base R; and

-   to visualize the analysis output by using ***ggplot2*** and ***tmap*** package.

# 2. GETTING STARTED

## 2.1 Objective - The Analytical Question

In geobusiness and spatial policy, a common approach is to divide a market or planning area into homogeneous regions based on multivariate data. In this hands-on exercise, we aim to segment Shan State, Myanmar into homogeneous regions using various Information and Communication Technology (ICT) measures, including: Radio, Television, Landline phones, Mobile phones, Computers, and Internet access at home.

## 2.2 The Data

Two data sets will be used in this study:

1.  **Myanmar Township Boundary Data (i.e. *myanmar_township_boundaries*):** This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.
2.  ***Shan-ICT.csv*****:** This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.

Both data sets are downloaded from [Myanmar Information Management Unit (MIMU)](http://themimu.info/).

## 2.3 Installing and Loading the R Packages

Before we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.

The R packages needed for this exercise are as follows:

-   Spatial data handling: ***sf**, **rgdal,** and **spdep***

-   Attribute data handling: ***tidyverse**, especially **readr**, **ggplot2** and **dplyr***

-   Choropleth mapping: ***tmap***

-   Multivariate data visualisation and analysis: ***coorplot**, **ggpubr**, and **heatmaply***

-   Cluster analysis: ***cluster,*** ***ClustGeo***

The code chunks below installs and launches these R packages into R environment.

```{r}
pacman::p_load(spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

Note: When using the `tidyverse`, there is no need to install the `readr`, `ggplot2`, and `dplyr` packages individually.

In fact, `tidyverse` also installs other valuable R packages like `tidyr`, making it a comprehensive solution for data manipulation and visualization.

## 2.4 Data Import and Preparation

### IMPORTING GEOSPATIAL DATA INTO THE R ENVIRONMENT

Let's import the Myanmar Township Boundary GIS data with its associated attribute table into the R environment.

The GIS data is in ESRI shapefile format and can be imported into R by using the `st_read()` function from the `sf` package.

The following code chunks demonstrate how to perform this task:

```{r}
shan_sf <- st_read(dsn = "data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

The imported township boundary object is called `shan_sf`. It is saved in **simple feature data.frame** format.

Let's check its content:

```{r}
shan_sf
```

The **sf.data.frame** is conformed to Hardy Wickham’s [tidy](https://edzer.github.io/rstudio_conf/#1) framework.

Since `shan_sf` is conformed to tidy framework, we can also use *`glimpse()`* to reveal the data type of it’s fields.

```{r}
glimpse(shan_sf)
```

### IMPORTING ASPATIAL DATA INTO THE R ENVIRONMENT

To import the **csv** file, we are going to use the `read_csv` function of the ***readr*** package.

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```

The imported InfoComm variables are extracted from **The 2014 Myanmar Population and Housing Census Myanmar**.

The attribute data set is called *ict*. It is saved in R’s \* tibble data.frame\* format.

The code chunk below reveals the summary statistics of *ict* data.frame.

```{r}
summary(ict)
```

According to the results, there are a total of 11 fields and 55 observation in the tibble data.frame.

### DERIVE NEW VARIABLES USING THE ***dplyr*** PACKAGE

The values are measured in terms of the number of households. Using these values directly could introduce bias due to differences in the total number of households across townships. Typically, townships with a larger number of households will also show higher numbers of households owning radios, TVs, etc.

To address this issue, we will calculate the **penetration rate** for each ICT variable using the code chunk below.

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

Let us review the summary statistics of the newly derived penetration rates using the code chunk below.

```{r}
summary(ict_derived)
```

Notice that six new fields have been added into the data.frame. They are `RADIO_PR`, `TV_PR`, `LLPHONE_PR`, `MPHONE_PR`, `COMPUTER_PR`, and `INTERNET_PR`.

# 3. EXPLORATORY DATA ANALYSIS (EDA)

## 3.1 EDA Using Statistical Graphics

We can visualize the distribution of variables (e.g., the number of households with radios) by applying appropriate Exploratory Data Analysis (EDA) techniques, as demonstrated in the code chunk below.

Histograms are particularly useful for identifying the overall distribution of data values, such as whether the distribution is left-skewed, right-skewed, or normally distributed.

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

Boxplots are useful in detecting outliers.

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

Next, we will plot the distribution of the newly derived variables (e.g., the radio penetration rate) using the code chunk below. This will help us understand how the penetration rates are distributed across the townships.

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

The graph looks like it follows a normal distribution but a little right-skewed.

Multiple histograms are then plotted to show the distribution of selected variables from the `ict_derived` data frame.

The code chunks used to generate this visualization consist of two main parts. First, we will create individual histograms for each variable using the code chunk provided below.

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

Next, the *`ggarrange()`* function of the ***ggpubr***package is used to group these histograms together.

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

`RADIO_PR`**,** `TV_PR`, `LLPHONE_PR`, `COMPUTER_PR`, `INTERNET_PR` appear to be right-skewed, with most values concentrated around lower to mid-range penetration rates, and a few outliers at higher penetration rates.

`MPHONE_PR`'s distribution looks more spread out, showing a fairly balanced range of penetration rates, with a slight right skew as well.

## 3.2 EDA Using Choropleth Map

### JOINING GEOSPATIAL AND ASPATIAL DATA

Before preparing the choropleth map, we need to merge the geospatial data object (i.e., `shan_sf`) with the aspatial data frame (i.e., `ict_derived`). This can be done using the `left_join` function from the `dplyr` package. The `shan_sf` simple feature data frame will serve as the base data object, while `ict_derived` will be the join table.

The code chunk below demonstrates how to perform this task, using `TS_PCODE` as the unique identifier to merge both data objects.

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
  
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

The message above shows that the `TS_CODE` is the common field used to perform the left-join.

It is important to note that there is no new output data been created. Instead, the data fields from `ict_derived` data frame are now updated into the data frame of `shan_sf`.

```{r}
shan_sf <- read_rds("data/rds/shan_sf.rds")
```

After using `write_rds`, the code chunk above reads an RDS file (`shan_sf.rds`) containing the `shan_sf` spatial data and loads it into the R environment as the `shan_sf` object using the `read_rds()` function.

### PREPARING A CHOROPLETH MAP

Let's quickly examine the distribution of the Radio Penetration Rate in Shan State at the township level by preparing a choropleth map.

The code chunks below demonstrate how to create the choropleth using the `qtm()` function from the ***tmap*** package.

```{r}
qtm(shan_sf, "RADIO_PR")
```

To uncover any potential bias in the distribution shown in the choropleth map above due to the underlying total number of households in the townships, we will create two separate choropleth maps: one for the total number of households (i.e., `TT_HOUSEHOLDS.map`) and one for the total number of households with radios (`RADIO.map`). The code chunk below demonstrates how to create these maps.

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

It's evident from the choropleth maps above that townships with a relatively larger number of households also tend to have higher numbers of radio ownership.

Next, let's plot the choropleth maps showing the distribution of the total number of households and the radio penetration rate using the code chunk below. This will provide a clearer view of how radio ownership relates to the household distribution across townships.

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

Some townships with lighter colors in the "Total Households" map (indicating fewer households) have a relatively higher radio penetration rate, as shown by darker shades in the "Radio Penetration Rate" map. Conversely, some townships with a high number of households (darker colors in the "Total Households" map) don't necessarily correspond to the highest radio penetration rates, indicating that a large population doesn't always equate to higher penetration.

# 4. CORRELATION ANALYSIS

Before conducting cluster analysis, it's crucial to verify that the cluster variables are not highly correlated.

In this section, you'll learn how to use the `corrplot.mixed()` function from the `corrplot` package to visualize and analyze the correlations between the input variables.

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

The correlation plot above shows that `COMPUTER_PR` and `INTERNET_PR` are highly correlated. This suggest that only one of them should be used in the cluster analysis instead of both.

# 5. HIERARCHY CLUSTER ANALYSIS

In this section, we are going to perform Hierarchical Cluster Analysis.

## 5.1 Extracting Clustering Variables

The code chunk below will be used to extract the clustering variables from the `shan_sf` simple feature object into data.frame.

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

Note that the final list of clustering variables excludes the variable `INTERNET_PR` due to its high correlation with `COMPUTER_PR`.

Next, we will modify the data so that the rows are labeled by township names rather than row numbers, using the code chunk below.

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```

The row number has now been replaced with township name.

Now, let's delete the `TS.x` field:

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

## 5.2 Data Standardization

In cluster analysis, it's common to use multiple variables, often with different value ranges. To prevent the results from being biased toward variables with larger values, it is important to standardize the input variables before conducting the cluster analysis. This ensures that each variable contributes equally to the clustering process.

## 5.3 Min-Max Standardization

In the code chunk below, the `normalize()` function from the `heatmaply` package is used to standardize the clustering variables using the Min-Max method. Afterward, the `summary()` function is applied to display the summary statistics of the standardized clustering variables.

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

Note that the value ranges of the Min-Max standardized clustering variables are now between 0 and 1.

## 5.4 Z-Score Standardization

Z-score standardization can be easily performed using the `scale()` function from Base R. The code chunk below demonstrates how to standardize the clustering variables using the Z-score method.

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

Notice that the mean and standard deviation of the Z-score standardized clustering variables are 0 and 1, respectively.

**Note**: The `describe()` function from the **psych** package is used here instead of `summary()` from Base R because it provides the standard deviation.

**Warning**: The Z-score standardization method should only be used if it is assumed that all variables follow a normal distribution.

## 5.5 Visualizing the Standardized Clustering Variables

Beside reviewing the summary statistics of the standardised clustering variables, it is also a good practice to visualise their distribution graphical.

The code chunk below plot the scaled *Radio_PR* field.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

The raw values histogram shows the `Radio_PR` variable with its original range, concentrated around 300-400. The Min-Max standardization scales the values between 0 and 1, while preserving the shape of the distribution. The Z-score standardization centers the data around 0 with a standard deviation of 1, adjusting the scale but keeping the distribution pattern intact.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

## 5.6 Computing the Proximity Matrix

In R, several packages offer functions to calculate distance matrices. Here, we will compute the proximity matrix using the `dist()` function in R.

The `dist()` function supports six distance calculation methods: Euclidean, Maximum, Manhattan, Canberra, Binary, and Minkowski, with the default being the Euclidean distance.

The code chunk below demonstrates how to compute the proximity matrix using the Euclidean method.

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

The code chunk below can then be used to list the content of `proxmat` for visual inspection.

```{r}
proxmat
```

## 5.7 Computing Hierarchical Clustering

In R, several packages offer hierarchical clustering functions. In this hands-on exercise, we will use `hclust()` from the **R stats** package.

The `hclust()` function applies an agglomerative method to compute clusters. It supports eight clustering algorithms: `ward.D`, `ward.D2`, `single`, `complete`, `average (UPGMA)`, `mcquitty (WPGMA)`, `median (WPGMC)`, and `centroid (UPGMC)`.

The code chunk below performs hierarchical cluster analysis using the `ward.D` method. The output is stored in an object of class `hclust`, which describes the clustering tree (dendrogram) produced by the process.

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

We can then plot the tree using the code chunk below.

```{r}
plot(hclust_ward, cex = 0.6)
```

## 5.8 Selecting the Optimal Clustering Algorithm

One of the challenges in hierarchical clustering is identifying strong clustering structures. This issue can be addressed by using the `agnes()` function from the **cluster** package. While similar to `hclust()`, the `agnes()` function provides the agglomerative coefficient, which measures the strength of the clustering structure (with values closer to 1 indicating a stronger clustering structure).

The code chunk below demonstrates how to compute the agglomerative coefficients for all hierarchical clustering algorithms.

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(shan_ict, method = x)$ac
}

map_dbl(m, ac)
```

With reference to the output above, we can see that Ward’s method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward’s method will be used.

## 5.9 Determining Optimal Clusters

Another technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.

There are 3 commonly used methods to determine the optimal clusters, they are:

-   [Elbow Method](https://en.wikipedia.org/wiki/Elbow_method_(clustering))

-   [Average Silhouette Method](https://www.sciencedirect.com/science/article/pii/0377042787901257?via%3Dihub)

-   [Gap Statistic Method](http://www.web.stanford.edu/~hastie/Papers/gap.pdf)

### GAP STATISTIC METHOD

The gap statistic compares the total within-cluster variation for different values of ( k ) (number of clusters) with their expected values under a null reference distribution. The optimal number of clusters is the value of ( k ) that maximizes the gap statistic, meaning it has the largest gap between the clustering structure and a random uniform distribution of points.

To calculate the gap statistic, we will use the `clusGap()` function from the **cluster** package.

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

Also note that the [*hcut*](https://rpkgs.datanovia.com/factoextra/reference/hcut.html) function used is from the [**factoextra**](https://rpkgs.datanovia.com/factoextra/index.html) package.

Next, let's visualize the plot by using [*fviz_gap_stat()*](https://rpkgs.datanovia.com/factoextra/reference/fviz_nbclust.html) of [**factoextra**](https://rpkgs.datanovia.com/factoextra/index.html) package.

```{r}
fviz_gap_stat(gap_stat)
```

Checking the graph above, the recommended number of cluster to retain is 1. However, it is not logical to retain only one cluster. By examine the gap statistic graph, the 6-cluster gives the largest gap statistic and should be the next best cluster to pick.

**Note**: In addition to these commonly used approaches, the **NbClust** package, published by Charrad et al. (2014), offers 30 indices for determining the optimal number of clusters. It helps users find the best clustering scheme by analyzing various combinations of the number of clusters, distance measures, and clustering methods.

## 5.10 Interpreting the Dendrograms

In the dendrogram shown above, each leaf represents an individual observation. As you move up the tree, similar observations are grouped into branches, and these branches merge at higher levels.

The height of each merge, indicated on the vertical axis, reflects the level of (dis)similarity between observations. A higher merge height suggests greater dissimilarity between the observations being clustered. It's important to note that the similarity between two observations is determined only by the height at which their branches first merge, not by their horizontal proximity.

You can also visualize the selected clusters by drawing rectangles around them using the `rect.hclust()` function from **R stats**. The `border` argument allows you to set the colors for these cluster borders.

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

## 5.11 Visually-Driven Hierarchical Clustering Analysis

In this section, we will learn how to perform visually-driven hiearchical clustering analysis by using [*heatmaply*](https://cran.r-project.org/web/packages/heatmaply/index.html) package.

With **heatmaply**, we are able to build both highly interactive cluster heatmap or static cluster heatmap.

### TRANSFORMING THE DATAFRAME INTO A MATRIX

The data was loaded into a data frame, but it has to be a data matrix to make the heatmap.

The code chunk below will be used to transform the `shan_ict` data frame into a data matrix.

```{r}
shan_ict_mat <- data.matrix(shan_ict)
```

#### PLOTTING AN INTERACTIVE CLUSTER HEATMAP USING `heatmapply()`

In the code chunk below, `heatmaply()` of the [***heatmaply***](#0) package is used to build an interactive cluster heatmap.

```{r}
heatmaply(normalize(shan_ict_mat),
          Colv=NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 6,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="Geographic Segmentation of Shan State by ICT indicators",
          xlab = "ICT Indicators",
          ylab = "Townships of Shan State"
          )
```

## 5.12 Mapping the Clusters Formed

With closed examination of the dendrogram above, we have decided to retain six clusters.

[*cutree()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/cutree.html) of R Base will be used in the code chunk below to derive a 6-cluster model.

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

The output, called `groups`, is a list object.

To visualize the clusters, the `groups` object needs to be appended to the `shan_sf` simple feature object.

The code chunk below performs the join in three steps: 1. The `groups` list object is converted into a matrix. 2. `cbind()` is used to append the `groups` matrix to `shan_sf`, resulting in a new simple feature object called `shan_sf_cluster`. 3. The `rename()` function from the **dplyr** package is used to rename the `as.matrix.groups` field to `CLUSTER`.

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

Next, `qtm()` of the ***tmap*** package is used to plot the choropleth map that shows the clusters formed.

```{r}
qtm(shan_sf_cluster, "CLUSTER")
```

The choropleth map above shows that the clusters are highly fragmented. This is a common limitation when using non-spatial clustering algorithms, such as hierarchical cluster analysis, as these methods do not take spatial relationships into account, leading to scattered and less cohesive clusters.

# 6. SPATIALLY-CONTRAINED CLUSTERING: **SKATER** APPROACH

In this section, you will learn how to derive spatially constrained cluster by using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) method of [**spdep**](https://r-spatial.github.io/spdep/index.html) package.

## **6.1 Converting into *SpatialPolygonsDataFrame***

First, we need to convert `shan_sf` into SpatialPolygonsDataFrame. This is because SKATER function only support **sp** objects such as SpatialPolygonDataFrame.

The code chunk below uses [*as_Spatial()*](https://r-spatial.github.io/sf/reference/coerce-methods.html) of **sf** package to convert *shan_sf* into a SpatialPolygonDataFrame called *shan_sp*.

```{r}
shan_sp <- as_Spatial(shan_sf)
```

## 6.2 Computing the Neighbor List

Next, [poly2nd()](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package will be used to compute the neighbours list from polygon list.

```{r}
shan.nb <- poly2nb(shan_sp)
summary(shan.nb)
```

We can plot the neighbours list on shan_sp by using the code chunk below. Since we now can plot the community area boundaries as well, we plot this graph on top of the map. The first plot command gives the boundaries. This is followed by the plot of the neighbor list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. We also set the color to blue and specify add=TRUE to plot the network on top of the boundaries.

```{r}
coords <- st_coordinates(
  st_centroid(st_geometry(shan_sf)))
```

```{r}
plot(st_geometry(shan_sf), 
     border=grey(.5))
plot(shan.nb,
     coords, 
     col="blue", 
     add=TRUE)
```

Note that if you plot the network first and then the boundaries, some of the areas will be clipped. This is because the plotting area is determined by the characteristics of the first plot. In this example, because the boundary map extends further than the graph, we plot it first.

## **6.3** CALCULATING EDGE COSTS

Next, [*nbcosts()*](https://r-spatial.github.io/spdep/reference/nbcosts.html) of **spdep** package is used to compute the cost of each edge. It is the distance between it nodes. This function compute this distance using a data.frame with observations vector in each node.

The code chunk below is used to compute the cost of each edge.

```{r}
lcosts <- nbcosts(shan.nb, shan_ict)
```

For each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observation (from the neighbour list). Basically, this is the notion of a generalised weight for a spatial weights matrix.

Next, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed ***lcosts*** as the weights.

In order to achieve this, [*nb2listw()*](https://r-spatial.github.io/spdep/reference/nb2listw.html) of **spdep** package is used as shown in the code chunk below.

Note that we specify the *style* as **B** to make sure the cost values are not row-standardised.

```{r}
shan.w <- nb2listw(shan.nb, 
                   lcosts, 
                   style="B")
summary(shan.w)
```

## 6.4 COMPUTING THE MINIMUM SPANNING TREE

The minimum spanning tree is computed by mean of the [*mstree()*](https://r-spatial.github.io/spdep/reference/mstree.html) of **spdep** package as shown in the code chunk below.

```{r}
shan.mst <- mstree(shan.w)
```

After computing the MST, we can check its class and dimension by using the code chunk below.

```{r}
class(shan.mst)
```

```{r}
dim(shan.mst)
```

Note that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.

We can display the content of *shan.mst* by using *head()* as shown in the code chunk below.

```{r}
head(shan.mst)
```

The plot method for the MST include a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the township boundaries. We can see how the initial neighbour list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.

```{r}
plot(st_geometry(shan_sf), 
                 border=gray(.5))
plot.mst(shan.mst, 
         coords, 
         col="blue", 
         cex.lab=0.7, 
         cex.circles=0.005, 
         add=TRUE)
```

## 6.5 Computing spatially constrained clusters using SKATER method

The code chunk below compute the spatially constrained cluster using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) of **spdep** package.

```{r}
clust6 <- spdep::skater(edges = shan.mst[,1:2], 
                 data = shan_ict, 
                 method = "euclidean", 
                 ncuts = 5)
```

The *skater()* takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to **one less than the number of clusters**. So, the value specified is **not** the number of clusters, but the number of cuts in the graph, one less than the number of clusters.

The result of the *skater()* is an object of class **skater**. We can examine its contents by using the code chunk below.

```{r}
str(clust6)
```

The most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.

We can check the cluster assignment by using the conde chunk below.

```{r}
ccs6 <- clust6$groups
ccs6
```

We can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.

```{r}
table(ccs6)
```

Lastly, we can also plot the pruned tree that shows the five clusters on top of the townshop area.

```{r}
plot(st_geometry(shan_sf), 
     border=gray(.5))
plot(clust6, 
     coords, 
     cex.lab=.7,
     groups.colors=c("red","green","blue", "brown", "pink"),
     cex.circles=0.005, 
     add=TRUE)
```

## 6.6 Visualizing the Clusters Using a Choropleth Map

The code chunk below is used to plot the newly derived clusters by using SKATER method.

```{r}
groups_mat <- as.matrix(clust6$groups)
shan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)
qtm(shan_sf_spatialcluster, "SP_CLUSTER")
```

For easy comparison, it will be better to place both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.

```{r}
hclust.map <- qtm(shan_sf_cluster,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) 

shclust.map <- qtm(shan_sf_spatialcluster,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hclust.map, shclust.map,
             asp=NA, ncol=2)
```

# 7. SPATIALLY-CONSTRAINED CLUSTERING: *ClustGeo* Method

In this section, you will gain hands-on experience on using functions provided by **ClustGeo** package to perform non-spatially constrained hierarchical cluster analysis and spatially constrained cluster analysis.

## 7.1 A short note about the ClustGeo package

[**ClustGeo**](https://cran.r-project.org/web/packages/ClustGeo/) package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.

In the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \[0, 1\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.

The idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.

## 7.2 A Ward-like hierarchical clustering: ClustGeo

ClustGeo package provides function called `hclustgeo()` to perform a typical Ward-like hierarchical clustering just like `hclust()` you learned in previous section.

To perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.

```{r}
nongeo_cluster <- hclustgeo(proxmat)
plot(nongeo_cluster, cex = 0.5)
rect.hclust(nongeo_cluster, 
            k = 6, 
            border = 2:5)
```

Note that the dissimilarity matrix must be an object of class `dist`, i.e. an object obtained with the function `dist()`. For sample code chunk, please refer to [5.7.6 Computing proximity matrix](https://r4gdsa.netlify.app/chap05#computing-proximity-matrix)

### MAPPING THE FORMED CLUSTERS

Similarly, we can plot the clusters on a categorical area shaded map by using the steps we learned in 5.7.12 Mapping the clusters formed.

```{r}
groups <- as.factor(cutree(nongeo_cluster, k=6))
```

```{r}
shan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
qtm(shan_sf_ngeo_cluster, "CLUSTER")
```

## 7.3 Spatially Constrained Hierarchical Clustering

Before we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of sf package.

```{r}
dist <- st_distance(shan_sf, shan_sf)
distmat <- as.dist(dist)
```

Notice that `as.dist()` is used to convert the data frame into matrix.

Next, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.

```{r}
cr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)
```

With reference to the graphs above, alpha = 0.3 will be used as shown in the code chunk below.

```{r}
clustG <- hclustgeo(proxmat, distmat, alpha = 0.3)
```

Next, `cutree()` is used to derive the cluster objecct.

```{r}
groups <- as.factor(cutree(clustG, k=6))
```

We will then join back the group list with *shan_sf* polygon feature data frame by using the code chunk below.

```{r}
shan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

We can now plot the map of the newly delineated spatially constrained clusters.

```{r}
qtm(shan_sf_Gcluster, "CLUSTER")
```

# 8. VISUAL INTERPRETATION OF CLUSTERS

## 8.1 Visualizing Individual Clustering Variables

Code chunk below is used to reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster.

```{r}
ggplot(data = shan_sf_ngeo_cluster,
       aes(x = CLUSTER, y = RADIO_PR)) +
  geom_boxplot()
```

The boxplot reveals Cluster 3 displays the highest mean Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 6 and 5.

## 8.2 Multivariate Visualization

Past studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) of [**GGally**](https://ggobi.github.io/ggally/index.html) package.

```{r}
ggparcoord(data = shan_sf_ngeo_cluster, 
           columns = c(17:21), 
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of ICT Variables by Cluster") +
  facet_grid(~ CLUSTER) + 
  theme(axis.text.x = element_text(angle = 30))
```

The parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.

Note that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:

-   std: univariately, subtract mean and divide by standard deviation.

-   robust: univariately, subtract median and divide by median absolute deviation.

-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.

-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.

-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.

-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param

There is no one best scaling method to use. You should explore them and select the one that best meet your analysis need.

Last but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.

In the code chunk below, `group_by()` and `summarise()` of dplyr are used to derive mean values of the clustering variables.

```{r}
shan_sf_ngeo_cluster %>% 
  st_set_geometry(NULL) %>%
  group_by(CLUSTER) %>%
  summarise(mean_RADIO_PR = mean(RADIO_PR),
            mean_TV_PR = mean(TV_PR),
            mean_LLPHONE_PR = mean(LLPHONE_PR),
            mean_MPHONE_PR = mean(MPHONE_PR),
            mean_COMPUTER_PR = mean(COMPUTER_PR))
```
