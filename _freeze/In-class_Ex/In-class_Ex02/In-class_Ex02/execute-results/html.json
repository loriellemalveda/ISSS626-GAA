{
  "hash": "503ef56096e79b7cf2a586f21737290c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 2: Spatial Point Patterns Analysis: spatstat Methods\"\nauthor: \"Lorielle Malveda\"\ndate: \"September 2, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n---\n\n\n\nIn the first parts of this In-class Exercise, we are going to address some of the issues that my classmates and I have encountered while implementing the past exercises.\n\n# Issue 1: Installing *maptools*\n\n***maptools*** has retired and has already been removed from CRAN, which is one of the more popular R-package sources. However, it is still available in the **Posit Public Package Manager.**\n\nTo avoid ***maptools*** being downloaded and installed repetitively every time we run our Quarto Document, we will add the `#| eval: false` statement at the start of the code chunk.\n\ninstall.packages(\"maptools\", repos = \"[https://packagemanager.posit.co/cran/2023-10-13\")](https://packagemanager.posit.co/cran/2023-10-13%22))\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spNetwork, tmap, tidyverse)\n```\n:::\n\n\n\n# Issue 2: Creating Coastal Outline\n\nThis section will tackle the 2 functions under the ***sf*** package: st_combine() and st_union(). These 2 functions are used to combine multiple simple features into 1 simple feature.\n\n-   `st_combine` returns a single, combined geometry, with no resolved boundaries.\n\n-   If y-coordinates are missing, we can use `st_union(x)`, which returns a single geometry with resolved boundaries , otherwise will return a geometry for all union pairs of `x[i]` and `y[j]`.\n\n## Example: Working with `st_union()`\n\nLet's derived the coastal outline, which is an sf tibble data.frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\loriellemalveda\\ISSS626-GAA\\In-class_Ex\\In-class_Ex02\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nchildcare_sf <- st_read(\"data/geospatial/child-care-services-geojson.geojson\") %>%\n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `child-care-services-geojson' from data source \n  `C:\\loriellemalveda\\ISSS626-GAA\\In-class_Ex\\In-class_Ex02\\data\\geospatial\\child-care-services-geojson.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 1545 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nchildcare <- as_Spatial(childcare_sf)\nsg_sf <- mpsz_sf %>%\n  st_union()\nplot(sg_sf)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nChecking the other necessary R packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, tmap, ggplot2, ggstatsplot, dplyr, spatstat, raster, readxl)\n```\n:::\n\n\n\nFor the latter parts, we are going to discuss the ***spatstat*** package.\n\n# Introducing the ***spatstat*** package\n\nThe ***spatstat*** package is an R package used to analyze Spatial Point Patterns that focuses mainly on 2D point patterns, including multitype or marked points, in any spatial region.\n\n## Creating *ppp* objects from sf data.frame\n\nWe are going to introduce another approach to creating ***ppp*** objects, aside from the one we have discussed in the past Hands-on Exercise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcare_ppp <- as.ppp(childcare_sf)\nplot(childcare_ppp)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(childcare_ppp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  1545 points\nAverage intensity 1.91145e-06 points per square unit\n\nCoordinates are given to 11 decimal places\n\nmarks are of type 'character'\nSummary:\n   Length     Class      Mode \n     1545 character character \n\nWindow: rectangle = [11203.01, 45404.24] x [25667.6, 49300.88] units\n                    (34200 x 23630 units)\nWindow area = 808287000 square units\n```\n\n\n:::\n:::\n\n\n\nCreating an ***owin*** object from sf data.frame\n\nLet us now use `as.owin()` of the ***spatstat*** package to create an ***owin*** object from a polygon sf tibble data.frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_owin <- as.owin(sg_sf)\nplot(sg_owin)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sg_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWindow: polygonal boundary\n80 separate polygons (35 holes)\n                  vertices         area relative.area\npolygon 1            14650  6.97996e+08      8.93e-01\npolygon 2 (hole)         3 -2.21090e+00     -2.83e-09\npolygon 3              285  1.61128e+06      2.06e-03\npolygon 4 (hole)         3 -2.05920e-03     -2.63e-12\npolygon 5 (hole)         3 -8.83647e-03     -1.13e-11\npolygon 6              668  5.40368e+07      6.91e-02\npolygon 7               44  2.26577e+03      2.90e-06\npolygon 8               27  1.50315e+04      1.92e-05\npolygon 9              711  1.28815e+07      1.65e-02\npolygon 10 (hole)       36 -4.01660e+04     -5.14e-05\npolygon 11 (hole)      317 -5.11280e+04     -6.54e-05\npolygon 12 (hole)        3 -3.41405e-01     -4.37e-10\npolygon 13 (hole)        3 -2.89050e-05     -3.70e-14\npolygon 14              77  3.29939e+05      4.22e-04\npolygon 15              30  2.80002e+04      3.58e-05\npolygon 16 (hole)        3 -2.83151e-01     -3.62e-10\npolygon 17              71  8.18750e+03      1.05e-05\npolygon 18 (hole)        3 -1.68316e-04     -2.15e-13\npolygon 19 (hole)       36 -7.79904e+03     -9.97e-06\npolygon 20 (hole)        4 -2.05611e-02     -2.63e-11\npolygon 21 (hole)        3 -2.18000e-06     -2.79e-15\npolygon 22 (hole)        3 -3.65501e-03     -4.67e-12\npolygon 23 (hole)        3 -4.95057e-02     -6.33e-11\npolygon 24 (hole)        3 -3.99521e-02     -5.11e-11\npolygon 25 (hole)        3 -6.62377e-01     -8.47e-10\npolygon 26 (hole)        3 -2.09065e-03     -2.67e-12\npolygon 27              91  1.49663e+04      1.91e-05\npolygon 28 (hole)       26 -1.25665e+03     -1.61e-06\npolygon 29 (hole)      349 -1.21433e+03     -1.55e-06\npolygon 30 (hole)       20 -4.39069e+00     -5.62e-09\npolygon 31 (hole)       48 -1.38338e+02     -1.77e-07\npolygon 32 (hole)       28 -1.99862e+01     -2.56e-08\npolygon 33              40  1.38607e+04      1.77e-05\npolygon 34 (hole)       40 -6.00381e+03     -7.68e-06\npolygon 35 (hole)        7 -1.40545e-01     -1.80e-10\npolygon 36 (hole)       12 -8.36709e+01     -1.07e-07\npolygon 37              45  2.51218e+03      3.21e-06\npolygon 38             142  3.22293e+03      4.12e-06\npolygon 39             148  3.10395e+03      3.97e-06\npolygon 40              75  1.73526e+04      2.22e-05\npolygon 41              83  5.28920e+03      6.76e-06\npolygon 42             211  4.70521e+05      6.02e-04\npolygon 43             106  3.04104e+03      3.89e-06\npolygon 44             266  1.50631e+06      1.93e-03\npolygon 45              71  5.63061e+03      7.20e-06\npolygon 46              10  1.99717e+02      2.55e-07\npolygon 47             478  2.06120e+06      2.64e-03\npolygon 48             155  2.67502e+05      3.42e-04\npolygon 49            1027  1.27782e+06      1.63e-03\npolygon 50 (hole)        3 -1.16959e-03     -1.50e-12\npolygon 51              65  8.42861e+04      1.08e-04\npolygon 52              47  3.82087e+04      4.89e-05\npolygon 53               6  4.50259e+02      5.76e-07\npolygon 54             132  9.53357e+04      1.22e-04\npolygon 55 (hole)        3 -3.23310e-04     -4.13e-13\npolygon 56               4  2.69313e+02      3.44e-07\npolygon 57 (hole)        3 -1.46474e-03     -1.87e-12\npolygon 58            1045  4.44510e+06      5.68e-03\npolygon 59              22  6.74651e+03      8.63e-06\npolygon 60              64  3.43149e+04      4.39e-05\npolygon 61 (hole)        3 -1.98390e-03     -2.54e-12\npolygon 62 (hole)        4 -1.13774e-02     -1.46e-11\npolygon 63              14  5.86546e+03      7.50e-06\npolygon 64              95  5.96187e+04      7.62e-05\npolygon 65 (hole)        4 -1.86410e-02     -2.38e-11\npolygon 66 (hole)        3 -5.12482e-03     -6.55e-12\npolygon 67 (hole)        3 -1.96410e-03     -2.51e-12\npolygon 68 (hole)        3 -5.55856e-03     -7.11e-12\npolygon 69             234  2.08755e+06      2.67e-03\npolygon 70              10  4.90942e+02      6.28e-07\npolygon 71             234  4.72886e+05      6.05e-04\npolygon 72 (hole)       13 -3.91907e+02     -5.01e-07\npolygon 73              15  4.03300e+04      5.16e-05\npolygon 74             227  1.10308e+06      1.41e-03\npolygon 75              10  6.60195e+03      8.44e-06\npolygon 76              19  3.09221e+04      3.95e-05\npolygon 77             145  9.61782e+05      1.23e-03\npolygon 78              30  4.28933e+03      5.49e-06\npolygon 79              37  1.29481e+04      1.66e-05\npolygon 80               4  9.47108e+01      1.21e-07\nenclosing rectangle: [2667.54, 56396.44] x [15748.72, 50256.33] units\n                     (53730 x 34510 units)\nWindow area = 781945000 square units\nFraction of frame area: 0.422\n```\n\n\n:::\n:::\n\n\n\n## Combining a Point Events Object and an *owin* Object\n\nThe code chunk below creates a ***ppp*** object by combining ***childcare_ppp*** and ***sg_owin***.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp = childcare_ppp[sg_owin]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(childcareSG_ppp)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nThe output object combined both the point and polygon feature in 1 ***ppp*** object class.\n\n## Kernel Density Estimation of a Spatial Point Event\n\nThe code chunk below re-scales the unit of measurement from meter –\\> kilometer before performing KDE.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, \n                                  1000, \n                                  \"km\")\n\nkde_childcareSG_adaptive <- adaptive.density(\n  childcareSG_ppp.km, \n  method=\"kernel\")\nplot(kde_childcareSG_adaptive)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nThere are 2 different ways to convert the KDE output into a grid object.\n\n1.  ***maptools*** method\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(bg = '#E4D5C9')\n\ngridded_kde_childcareSG_ad <- maptools::as.SpatialGridDataFrame.im(\n  kde_childcareSG_adaptive)\nspplot(gridded_kde_childcareSG_ad)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n2.  **spatstat.geom** method\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngridded_kde_childcareSG_ad <- as(\n  kde_childcareSG_adaptive,\n  \"SpatialGridDataFrame\")\nspplot(gridded_kde_childcareSG_ad)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## Visualizing KDE using ***tmap***\n\nThe code chunk below is used to plot the output raster by using ***tmap*** functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_childcareSG_ad_raster <- raster(kde_childcareSG_adaptive)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(kde_childcareSG_ad_raster) + \n  tm_raster(palette = \"viridis\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"), \n            frame = FALSE,\n            bg.color = \"#E4D5C9\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Extracting Study Area Using ***sf*** Objects\n\nWe are going to extract and create a ***ppp*** object showing child care services within the Punggol Planning Area.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npg_owin <- mpsz_sf %>%\n  filter(PLN_AREA_N == \"PUNGGOL\") %>%\n  as.owin()\n\nchildcare_pg = childcare_ppp[pg_owin]\n\nplot(childcare_pg)  \n```\n\n::: {.cell-output-display}\n![](In-class_Ex02_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nNote that we used `filter()` of the ***dplyr*** package to extract the target planning areas, i.e. for this case it is the Punggol Planning Area.\n\n## **Monte Carlo Simulation**\n\nNote: To ensure reproducibility, it is important to include the code chunk below before using ***spatstat*** functions involving **Monte Carlo** simulations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\n## Edge Correction Methods of ***spatstat***\n\nIn ***spatstat***, **Edge Correction Methods** helps avoid biases that arise when estimating spatial statistics near the boundaries of a study region.\n\nThis is important to ensure accurate estimates in spatial point pattern analysis, especially for summary statistics like the K-function, L-function, etc. even though doing this increases computing time.\n\n# Geospatial Analytics for Social Good: Thailand Road Accident Case Study\n\n## Background\n\n-   [Road traffic injuries](https://www.who.int/news-room/fact-sheets/detail/road-traffic-injuries), WHO.\n\n-   [Road traffic deaths and injuries in Thailand](https://cdn.who.int/media/docs/default-source/thailand/roadsafety/overview-en-final-25-7-19.pdf?sfvrsn=f9d7a862_2)\n\n## Study Area\n\nThe study area is [Bangkok Metropolitan Region](https://en.wikipedia.org/wiki/Bangkok_Metropolitan_Region).\n\n![](images/BMR.png)\n\nThailand's projected coordinate system is **WGS 84 / UTM zone 47N** and the EPSG code is 32647.\n\n## Data to be Used\n\nFor the purpose of this exercise, three basic data sets are needed, they are:\n\n-   [Thailand Road Accident \\[2019-2022\\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022) on Kaggle\n\n-   [Thailand Roads (OpenStreetMap Export)](https://data.humdata.org/dataset/hotosm_tha_roads) on HDX.\n\n-   [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) on HDX.\n\n## Importing Traffic Accident Data\n\nRecall the previous exercises and import the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrdacc_sf <- read_csv(\"data/thai_road_accident_2019_2022.csv\") %>%\n  filter(!is.na(longitude) & longitude != \"\",\n         !is.na(latitude) & latitude !=\"\") %>%\n  st_as_sf(coords= c(\"longitude\", \"latitude\"),\n           crs=4326) %>%\n  st_transform(crs=32647)\n```\n:::\n\n\n\n#\\| eval: false mutate(Month_num = month(incident_datetime) %\\>% mutate(Month_fac = month(incident_datetime, label=TRUE, abbr=TRUE)) %\\>% mutate(dayofweek = day(incident_datetime))\n\n```         \n\ncan delete using the painter tool\n\nwrite_rds(acc,\"data/rds/acc.rds\")\n```\n\nthis function takes care of objects internally\n\nacc \\<- read_rds(\"\") \\`\\`\\`\n\nthis is basically calling it back\n",
    "supporting": [
      "In-class_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}