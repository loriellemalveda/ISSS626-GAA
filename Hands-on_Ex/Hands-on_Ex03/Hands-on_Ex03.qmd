---
title: "Hands-on Exercise 3: 1st Order Spatial Point Patterns Analysis Methods"
author: "Lorielle Malveda"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
---

# 1. OVERVIEW

This is the 1st of 2 Hands-on Exercise devoted to Spatial Point Pattern Analysis.

***Spatial Point Pattern Analysis*** is the evalutation of any pattern or distribution of a set of points on a surface. These points can represent locations of various events like crimes, traffic accidents, and disease outbreaks, or they could indicate business services such as coffee shops and fast food outlets, as well as facilities like childcare and eldercare centers.

In this Hands-on Exercise, we will use relevant functions from the ***spatstat*** (for more info, click [here](https://cran.r-project.org/web/packages/spatstat/)) package to explore the spatial distribution of childcare centers in Singapore.

Specifically, this exercise aims to answer the following questions:

-   Are childcare centers in Singapore *randomly distributed* across the country?

-   If they are not, then where are the *areas with a higher concentration* of childcare centers?

# 2. GETTING STARTED

## 2.1 Acquire Data

The following datasets will be used:

-   `CHILDCARE` in geojson format (from data.gov.sg)

    -   a *point feature data* providing both location and attribute information of childcare centers.

-   `MP14_SUBZONE_WEB_PL` in ESRI shapefile format (from data.gov.sg)

    -   a *polygon feature data* providing information of the URA 2014 Master Plan Planning Subzone boundary data.

-   `CostalOutline` in ESRI shapefile format (from SLA)

    -   a *polygon feature data* showing the national boundary of Singapore.

## 2.2 Install and Launch R Packages

```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse, maptools)
```

This code chunk uses `p_load()` of the ***pacman*** package (stands for Package Manager) to check if the following packages are installed:

-   [**sf**](https://r-spatial.github.io/sf/): designed to import, manage, and process vector-based geospatial data in R.

-   [**spatstat**](https://spatstat.org/): useful for point pattern analysis. We will use this to perform 1st- and 2nd-order Spatial Point Patterns Analysis and to derive the Kernel Density Estimation (KDE) layer.

-   [**raster**](https://cran.r-project.org/web/packages/raster/): reads, writes, manipulates, analyzes, and model gridded spatial data (i.e. raster). We will use this to convert image outputs generated by ***spatstat*** into ***raster*** format.

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html): provides tools for manipulating geographic data. We will mainly use this to convert Spatial objects into the ***ppp*** format required by ***spatstat***.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html): you must now be familiar with this as we have used this in the previous Hands-on Exercises. This provides functions for cartographic quality static point patterns or interactive maps by using the [Leaflet](https://leafletjs.com/) API.

If available, the packages will then be launched into R.

# 3. SPATIAL DATA WRANGLING

## 3.1 Importing the Spatial Data

To import the datasets, `st_read()` of the ***sf*** package will be used.

```{r}
childcare_sf <- st_read("data/data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "data/data", layer="CostalOutline")
```

```{r}
mpsz_sf <- st_read(dsn = "data/data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

Before proceeding to analysis, let us check first if they are all in the same projection system. **Do not forget to do this! :)**

REVIEW: Using the ***sf*** function we learned before, we will retrieve the referencing system information of the geospatial data.

```{r}
st_crs(childcare_sf)
```

```{r}
st_crs(sg_sf)
```

```{r}
childcare_sf
```

```{r}
st_crs(mpsz_sf)
```

Notice that except for ***childcare_sf***, ***mpsz_sf*** and ***sg_sf*** do not have proper crs information.

REVIEW: Remember what was discussed in Lesson 2 and assign the correct crs to the 2 datasets.

```{r}
mpsz_sf3414 <- st_transform(mpsz_sf, 
                              crs = 3414)
```

```{r}
sg_sf3414 <- st_transform(sg_sf, 
                              crs = 3414)
```

Checking!

```{r}
st_crs(mpsz_sf3414)
```

```{r}
st_crs(sg_sf3414)
```

There is no need to change the referencing system as it is already at the Singapore National Projected Coordinate System.

## 3.2 Mapping the Geospatial Datasets

After verifying the coordinate reference system for each geospatial dataset, it is also helpful to create a map to visualize their spatial patterns.

Review: Use the mapping techniques learned prior to this exercise, and create a map.

```{r}
tmap_mode("plot")

tm_shape(mpsz_sf3414) +  
  tm_polygons(col = "lightgrey") +
  tm_shape(childcare_sf) + 
  tm_dots()

```

This code sets the ***tmap*** mode to "`plot`" for static map visualization. It then creates a map where the `mpsz_sf3414` polygon layer is displayed with light grey polygons, and the `childcare_sf` point layer is overlaid as dots to show the locations of childcare centers.

Notice that all the geospatial layers fit within the same map extent. This shows that their referencing system and coordinate values are within a common spatial context.

Alternatively, we can also prepare a more interactive map by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

At the interactive mode, ***tmap*** uses Leaflet for R's API. With an interactive map, you can freely navigate and zoom in and out of the map. It also adds to the experience of exploring!

Additionally, you can change the map's background layer. Currently, three internet map layers are provided. They are `ESRI.WorldGrayCanvas`, `OpenStreetMap`, and `ESRI.WorldTopoMap.` The default is `ESRI.WorldGrayCanvas`.

```{r}
tmap_mode('plot')
```

***Reminder!*** Always remember to switch back to plot mode after the interactive map.

Interactive mode uses a connection, and you should avoid displaying too many interactive maps (no more than 10) in a single RMarkdown document when publishing on Netlify.

# 4. GEOSPATIAL DATA WRANGLING

Although simple feature data frames are becoming increasingly popular compared to ***sp’s Spatial*** classes, many geospatial analysis packages still require input data in ***sp’s Spatial*** format. In this section, we are going to convert a simple feature data frame to ***sp’s Spatial*** class.

## 4.1 Converting the ***sf*** data frames to *sp's Spatial* class

We will use `as_Spatial()` of the ***sf*** package to convert the geospatial data from a simple feature data frame to ***sp's Spatial*** class.

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

Now let us check if the geospatial data has been converted into their respective ***sp's Spatial*** classes.

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

They are now successfully converted!

## 4.2 Converting the Spatial class into generic sp format

**spatstat** requires that the data be in ***ppp*** object form. There is no direct way for converting ***Spatial*** classes into ***ppp*** objects. We first need to convert the ***Spatial*** classes into ***Spatial*** objects first.

The codes chunk below converts data in ***Spatial*** classes into ***generic sp*** objects.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

Checking:

```{r}
childcare_sp
```

```{r}
sg_sp
```

What are the differences between Spatial\* classes and generic sp object?

The conversion from ***Spatial*** classes to ***generic sp objects*** makes a more standardized format that is compatible with various functions and packages that work with spatial data. This makes it easier to perform operations across different types of spatial data.

## 4.3 **Converting the generic sp format into spatstat’s ppp format**

The code chunk below uses the `ppp()` function of the ***spatstat*** package to convert spatial data to ***spatstat's ppp*** object format.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
childcare_ppp
```

Now, let us plot `childcare_ppp` and examine the difference.

```{r}
plot(childcare_ppp)
```

Let us also take a look at the summary statistics to get an overview/feel of how the data is like.

```{r}
summary(childcare_ppp)
```

## 4.4 Handling duplicated points

Here is how we check for duplicates in a ***ppp*** object:

```{r}
any(duplicated(childcare_ppp))
```

We will then use the `multiplicity()` function to count the number of co-incidence points. According to rdocumentation.org, the function is intended to count the number of duplicates of each element of an object.

```{r}
multiplicity(childcare_ppp)
```

To check how many locations have more than one-point event:

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The output shows that there are 128 duplicated point events. To view the locations of the duplicate point events, we will plot `childcare` data by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

Do not forget to put `tmap_mode` back to '`plot`'! :)

```{r}
tmap_mode('plot')
```

How to spot the duplicate points from the map shown above?

Check the interactive map carefully. The ***darker shaded points*** are those that are overlapping.

Treating Duplicates:

Resolving duplicates can be approached in three ways.

1.  The simplest method is to ***delete the duplicates***, though this would result in a loss of someway of valuable point events.
2.  Apply ***jittering***, which introduces slight variations to the duplicate points, preventing them from occupying the same exact position.
3.  Make each point ***"unique"*** and then attaching the duplicate points as marks or attributes. This requires using analytical techniques that account for these marks.

The code chunk below implements the ***jittering*** approach.

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Checking for the new dataset where the ***jittering*** approach has been used:

```{r}
any(duplicated(childcare_ppp_jit))
```

```{r}
multiplicity(childcare_ppp_jit)
```

```{r}
sum(multiplicity(childcare_ppp_jit) > 1)
```

## 4.5 Creating owin object

When analyzing spatial point patterns, it is recommended to limit the analysis to a specific geographical area, for example, the boundaries of Singapore. An object called ***owin*** under the ***spatstat*** package is specifically designed to represent this polygonal region.

The code snippet below shows how to convert the ***sgSpatialPolygon*** object into an ***owin*** object in ***spatstat***.

```{r}
sg_owin <- as.owin(sg_sf)
```

Use the `plot()` function to display the output object.

```{r}
plot(sg_owin)
```

and `summary()` function of Base R.

```{r}
summary(sg_owin)
```

## 4.6 Combining point events object and owin object.

We are now at the last step of geospatial data wrangling! Check out the code below to extract childcare events that are located within Singapore.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

The output object combined both the point and polygon feature in one ppp object class as shown below.

```{r}
summary(childcareSG_ppp)
```

Let us now plot the derived ***childcareSG_ppp***.

```{r}
plot(childcareSG_ppp)
```

# 5. FIRST-ORDER SPATIAL POINT PATTERNS ANALYSIS (SPPA)

Now we proceed with first-order SPPA by using the **spatstat** package.

Hang in, there! We are almost done!

The Hands-on Exercise will focus on:

-   deriving the **Kernel Density Estimation (KDE)** layer for visualizing and exploring the intensity of point processes and

-   performing **Confirmatory Spatial Point Patterns Analysis** by using the **Nearest Neighbor** statistics.

## 5.1 Kernel Density Estimation

Let us compute for the KDE of Childcare Services in Singapore.

### COMPUTING KDE USING THE AUTOMATIC BANDWIDTH SELECTION METHOD

We are going to compute for KDE by using the following configurations of the function *`density()`* of **spatstat**:

-   ***Automatic Bandwidth Selection Method*** using **`bw.diggle()`**
    -   Other methods include: `bw.CvL()` , `bw.scott()` , `bw.ppl()`
-   ***Smoothing Kernel*** using *`gaussian`* (default).
    -   Other smoothing methods are: **“`epanechnikov`” , “`quartic`” , “`disc`”**.
-   ***Intensity Estimate*** is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is *FALSE*.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

Using the `plot()` function:

```{r}
plot(kde_childcareSG_bw)
```

The plot displays the KDE, to which values range from 0 to 0.000035 (way too small to comprehend).

Why are the values small?

It is because the default unit of measurement of ***svy21*** is in ***meters***. As a result, the computed values should be interpreted in **“number of points per square meter”**.

We may also retrieve the bandwidth used to compute the KDE layer by using the code chunk below.

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### RESCALING KDE VALUES

`rescale.ppp()` is used to convert the unit of measurement from meters(m) to kilometers(km).

```{r}
childcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, 1000, "km")
```

Let's observe the rescaled dataset.

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

The axis on the right now looks better and easier to understand! Take note that the actual map looks similar to the first version we recently created, just that the legend has changed after rescaling.

## 5.2 Working with Different Automatic Bandwidth Methods

-   ***Automatic Bandwidth Selection Method*** using **`bw.diggle()`**
    -   Other methods include: `bw.CvL()` , `bw.scott()` , `bw.ppl()`

Let us take a look at the other methods one by one.

```{r}
 bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

According to Baddeley et al. (2016), the **`bw.ppl()` algorithm** is recommended, as it often yields more appropriate results when the pattern primarily consists of tight clusters. However, if the goal of a study is to identify a single tight cluster amid random noise, the **`bw.diggle()`** method tends to perform better.

Let's check the comparison below.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

## 5.3 Working with Different Kernel Methods

-   ***Smoothing Kernel*** using *`gaussian`* (default).
    -   Other smoothing methods are: **“`epanechnikov`” , “`quartic`” , “`disc`”**.

The code chunk below will compute 3 more kernel density estimations by using these 3 other functions.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

# 6. FIXED AND ADAPTIVE KDE

## 6.1 Computing KDE by Using Fixed Bandwidth

Let's now compute a KDE layer by defining a bandwidth of 600m.

iI the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of ***childcareSG_ppp.km*** is in kilometer, i.e. 600m –\> 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

## 6.2 Computing KDE by Using Adaptive Bandwidth

The previous method, which is the **Fixed Bandwidth Metho**d, is very sensitive to highly skewed distribution of spatial point patterns over geographical units. One example is urban vs. rural. To solve this problem, we can opt to use **Adaptive Bandwidth** instead.

The code chunk below derives the adaptive kernel density estimation by using `density.adaptive()` of ***spatstat***.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

Let us compare the 2 methods below.

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

## 6.3 Converting KDE Output into Grid Object

The result is the same, we just convert it so that it is suitable for mapping purposes.

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

Author's note: I encountered an error while running the code chunk the first time. In case you find yourself in the same situation, check this [stackoverflow](https://stackoverflow.com/questions/77511849/i-have-obtained-some-error-trying-to-install-maptools-in-rstudio) post.

### CONVERTING GRIDDED OUTPUT INTO RASTER

Next, we will convert the ***gridded kernal density objects*** into a ***RasterLayer object*** by using `raster()` of the [***raster***](https://cran.r-project.org/web/packages/raster/index.html) package.

```{r}
kde_childcareSG_bw_raster <- raster(kde_childcareSG.bw)
```

Deep diving:

```{r}
kde_childcareSG_bw_raster
```

If you look at the results more closely, you can see that the CRS property is NA.

### ASSIGNING PROJECTION SYSTEMS

To solve the issue above, let us include the CRS information using the code chunk below:

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

Now we can see an input in the CRS property! :)

## 6.4 Visualizing the Output in ***tmap***

Finally, we display the raster in cartographic quality map using the ***tmap*** package.

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("layer", palette = "viridis") +
  tm_layout(legend.position = c("left", "bottom"), frame = FALSE)
```

## 6.5 Comparing Spatial Point Patterns Using KDE

In this section, we are going to compare the KDEs of childcare centers in Ponggol, Tampines, Chua Chu Kang and Jurong West - the 4 planning areas.

### EXTRACTING STUDY AREA

The code chunk below will be used to extract the target planning areas.

```{r}
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

Plotting the target planning areas

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
```

```{r}
plot(tm, main = "Tampines")
```

```{r}
plot(ck, main = "Choa Chu Kang")
```

```{r}
plot(jw, main = "Jurong West")
```

### CREATING OWIN OBJECT

Just like what we have done before, we will now convert these ***sf*** objects into ***owin*** objects.

```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

### COMBINING CHILDCARE POINTS AND THE STUDY AREA

By using the code chunk below, we are able to extract the childcare centers within the specific regions.

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

`rescale.ppp()` is used to convert the unit of measurement from meters(m) to kilometers(km).

```{r}
childcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, "km")
```

Plotting the 4 regions:

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

### COMPUTING KDE

Just like what we learned in the previous sections, we are computing the KDE of these 4 planning areas.

Let's use the `bw.diggle()` method to derive the bandwidth of each planning region.

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
```

### COMPUTING FIXED BANDWIDTH KDE

For comparison purposes, we will use 250m as the bandwidth.

```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

# 7. NEAREST NEIGHBOR ANALYSIS

Let us now learn about the ***Clark-Evans Test of Aggregation*** for a spatial point pattern by using the `clarkevans.test()` of ***statspat***.

The test hypotheses are:

**H~o~ = *The distribution of childcare services is randomly distributed.***

**H~1~= *The distribution of childcare services is not randomly distributed.***

We are going to use a **95% Confidence Interval.**

## 7.1 Testing Spatial Point Patterns Using Clark and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

**Some observations:**

-   **R is less than 1**, which is indicative that the childcare centers in Singapore are ***more clustered than randomly distributed***.
-   Given the **p-value**, there is evidence to ***reject the null hypothesis***.

## 7.2 Clark and Evans Test: Choa Chu Kang Planning Area

Let us check for the Choa Chu Kang Planning Area:

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

-   **R** **is close to 1**, which is indicative that there is ***near random distribution***.

-   **p-value** is higher than the confidence level (alpha = 0.05), which means there is ***no strong evidence to say the we must reject the null hypothesis***.

## 7.3 Clark and Evans Test: Tampines Planning Area

For the Tampines Planning Area:

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

-   **R is less than 1**, which is indicative that the childcare centers in Singapore are ***more clustered than randomly distributed***.

-   Given the **p-value**, there is evidence to ***reject the null hypothesis and accept the alternative hypothesis that the points are not randomly distributed***.
