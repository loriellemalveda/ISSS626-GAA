{
  "hash": "048c465c0e4629ff753c8e0e0e865905",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 9: Modelling Geographic of Accessibility\"\nauthor: \"Lorielle Malveda\"\ndate: \"October 25, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n---\n\n\n\n# **1. INTRODUCTION**\n\nIn this hands-on exercise, we will focus on modelling geographical accessibility using R’s Geospatial Analysis Packages.\n\n# **2. LEARNING OUTCOME**\n\nThe goals of this Hands-on Exercise are as follows:\n\n-   to import **GIS polygon data** into R and save them as simple feature data frame using the appropriate functions of the ***sf*** package in R;\n-   to import **aspatial data** into R and save them as simple feature data frame by using the appropriate functions of the ***sf*** package in R;\n-   to computer accessibility measures using the Hansen’s Potential Model and Spatial Accessibility Measure (SAM); and\n-   to visualize the accessibility measures by using the ***tmap*** and ***ggplot2*** packages.\n\n# 3. THE DATA\n\nWe will use 4 datasets, namely:\n\n1.  `MP14_SUBZONE_NO_SEA_PL`: URA Master Plan 2014 subzone boundary GIS data. This data set is downloaded from *data.gov.sg*.\n\n2.  `hexagons`: A 250m radius hexagons GIS data. This data set was created by using [`st_make_grid()`](https://r-spatial.github.io/sf/reference/st_make_grid.html) of the ***sf*** package. It is in the ESRI shapefile format.\n\n3.  `ELDERCARE`: This is GIS data showing locations of eldercare services. This is also downloaded from data.gov.sg. There are two versions: One in ESRI shapefile format, and the other one in Google kml file format. For the purpose of this hands-on exercise, we are using the ESRI shapefile format.\n\n4.  `OD_Matrix`: a distance matrix in csv format, which includes 6 fields. They are:\n\n    -   `origin_id`: the unique id values of the origin (i.e. `fid` of hexagon data set.),\n\n    -   `destination_id`: the unique id values of the destination (i.e. `fid` of `ELDERCARE` data set.),\n\n    -   `entry_cost`: the perpendicular distance between the origins and the nearest road),\n\n    -   `network_cost`: the actual network distance from the origin and destination,\n\n    -   `exit_cost`: the perpendicular distance between the destination and the nearest road), and\n\n    -   `total_cost`: the summation of `entry_cost`, `network_cost` and `exit_cost`.\n\nAll the values of the cost related fields are in **metres**.\n\n::: callout-note\n**Reminder:** *Except* `MP14_SUBZONE_NO_SEA_PL` *data set, the other three data set are specially prepared by Prof. Kam for teaching and research purpose. Students taking IS415 Geospatial Analytics and Applications are allowed to use them for hands-on exercise purpose. Please obtain formal approval from Prof. Kam if you want to use them for other courses or usage.*\n:::\n\n# 4. GETTING STARTED\n\nBefore getting started, let's first install the necessary R packages and launch them into the RStudio environment.\n\nThe R packages needed for this exercise are as follows:\n\n-   **sf**: for spatial data handling\n\n-   **spatialAcc**: for modelling geographical accessibility\n\n-   **tidyverse, especially readr and dplyr**: attribute data handling\n\n-   **tmap**: used for thematic mapping\n\n-   **ggplot2:** useful for statistical graphics\n\n-   **ggstatsplot**: statistical analysis\n\nThe code chunk below installs and launches these R packages into the RStudio environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n```\n:::\n\n\n\n::: callout-note\nBy installing ***tidyverse***, we need not install ***readr***, ***dplyr,*** and ***ggplots*** packages separately. In fact, tidyverse also installs other R packages such as ***tidyr, stringr, forcats, tibble, purrr and magrittr***.\n:::\n\n# 5. GEOSPATIAL DATA WRANGLING\n\n## 5.1 Importing Geospatial Data\n\nThree geospatial datasets will be imported from the *data/geospatial* sub-folder.\n\nThey are MP14_SUBZONE_NO_SEA_PL, hexagons and ELDERCARE.\n\nThe code chunk below is used to import these datasets using the `st_read()` function of the ***sf*** packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\loriellemalveda\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `C:\\loriellemalveda\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `C:\\loriellemalveda\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\n\nThe report above indicates that the R object containing the imported `MP14_SUBZONE_WEB_PL` shapefile is named `mpsz` and is a simple feature object with a geometry type of multipolygon. It’s also important to note that the `mpsz` simple feature object lacks EPSG information.\n\n## 5.2 Updating CRS Information\n\nDo not forget to correct the EPSG code! We will set it to \"3414\".\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414) \neldercare <- st_transform(eldercare, 3414) \nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\n\nAfter transforming the projection metadata, you can verify the projection of the newly transformed `mpsz_svy21` by using `st_crs()` from the `sf` package.\n\nThe code snippet below will be used to verify the newly transformed `mpsz_svy21`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n\nThe ***EPSG code*** is indicated as *3414* now.\n\n## 5.3 Cleaning and Updating Attribute Fields of the Geospatial Data\n\nThe data tables of both `eldercare` and `hexagons` contain several redundant fields. The code chunks below will be used to exclude these redundant fields.\n\nAdditionally, a new field named `demand` will be added to the `hexagons` data table, and a new field named `capacity` will be added to the `eldercare` sf data frame. Both fields will be derived using the `mutate()` function from the `dplyr` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\n\n::: callout-note\nFor the purpose of this hands-on exercise, a constant value of 100 is used. In practice, actual demands of the hexagon and capacity of the eldercare centres should be used.\n:::\n\n# **6. ASPATIAL DATA HANDLING AND WRANGLING**\n\n## 6.1 Importing the Distance Matrix\n\nThe code chunk below uses the `read_csv()` function of the ***readr*** package to import `OD_Matrix.csv` into RStudio. The imported object is a tibble data.frame called `ODMatrix`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n:::\n\n\n\n## **6.2 Tidying the Distance Matrix**\n\nThe imported ***ODMatrix*** organized the distance matrix column-wise.\n\n![](images/clipboard-3158646600.png)\n\nOn the other hands, most of the modelling packages in R is expecting a matrix look similar to the figure below.\n\n![](images/image2.jpg){width=\"544\"}\n\nThe rows represent **origins** (i.e. also know as **from** field) and the columns represent **destination** (i.e. also known as **to** field.)\n\nThe code chunk below uses `spread()` of the ***tidyr*** package to transform the OD matrix from a thin format into a fat format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  spread(destination_id, total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n\n\n::: callout-note\nNote: Since the tidyr version 1.0, a new function called `pivot_wider()` is introduced. Let's use this instead of `spread()`.\n:::\n\nCurrently, the distance is measured in metres because the SVY21 projected coordinate system is used.\n\nLet's convert the unit f measurement from ***metres to kilometres***.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n\n# 7. MODELLING AND VISUALIZING ACCESSIBILITY USING HANSEN METHOD\n\n## 7.1 Computing Hansen’s Accessibility\n\nNow, we are ready to compute Hansen’s accessibility. Let's use `ac()` of the [**SpatialAcc**](https://cran.r-project.org/web/packages/SpatialAcc/index.html) package.\n\nBefore getting started, you are encouraged to read the [arguments](https://cran.r-project.org/web/packages/SpatialAcc/SpatialAcc.pdf) of the function at least once in order to ensure that the required inputs are available.\n\nThe code chunk below calculates Hansen’s accessibility using `ac()` of **SpatialAcc** and `data.frame()` is used to save the output in a data frame called `acc_Handsen`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n```\n:::\n\n\n\n![](images/clipboard-2156183258.png)\n\nThe default field name is very messy and long. Therefore, let's rename it to `accHansen` by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\n```\n:::\n\n\n\nNow the column name looks tidier now.\n\n![](images/clipboard-1830147547.png)\n\nNext, we will convert the data table into tibble format by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- tbl_df(acc_Hansen)\n```\n:::\n\n\n\nLastly, `bind_cols()` of the ***dplyr*** package will be used to join the `acc_Hansen` tibble data frame with `hexagons` simple feature data frame. We name the output `hexagon_Hansen`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n\nNotice that hexagon_Hansen is a simple feature data frame and not a typical tibble data frame.\n\nLet's combine the steps above in a single code chunk as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 0.5, \n                            family = \"Hansen\"))\n\ncolnames(acc_Hansen) <- \"accHansen\"\nacc_Hansen <- tbl_df(acc_Hansen)\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n\n## 7.2 Visualizing Hansen’s Accessibility\n\n### EXTRACTING MAP EXTEND\n\nFirst, we will extract the extent of the `hexagons` simple feature data frame using `st_bbox()` from the ***sf*** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\n\nThe code snippet below uses a collection of mapping functions from the `tmap` package to create a high-quality cartographic map showing accessibility to eldercare centers in Singapore.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n### STATISTICAL GRAPHIC VISUALIZATION\n\nIn this section, we will compare the distribution of Hansen’s accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the `hexagon_Hansen` simple feature data frame using the code snippet below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nNext, let's utilize `ggplot()` to plot the distribution using boxplots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n# 8. MODELLING AND VISUALIZING ACCESSIBILITY USING THE KD2SFCA METHOD\n\n## 8.1 Computing KD2SFCA’s accessibility\n\nIn this section, we are going to repeat the steps we had learned in previous section to perform the analysis. Some multiple codes will be combined into one code chunk.\n\nThe code chunk below calculates Hansen’s accessibility using `ac()` of **SpatialAcc**. `data.frame()` is used to save the output in a dataframe called `acc_KD2SFCA`.\n\nNotice that `KD2SFCA` is used for the \"family\" argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- tbl_df(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n\n## 8.2 Visualizing KD2SFCA’s accessibility\n\nThe code chunk below uses a collection of mapping functions of the ***tmap*** package to create a high cartographic quality accessibility to eldercare centres in Singapore. We reused `mapex` for the *bbox* argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n## 8.3 Statistical Graphic Visualization\n\nLet's now compare the distribution of KD2CFA accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field into *`hexagon_KD2SFCA`* simple feature data frame using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\n\nNext, `ggplot()` will be used to plot the distribution by using boxplots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n# 9. MODELLING AND VISUALIZING ACCESSIBILITY USING THE SPATIAL ACCESSIBILITY MEASURE (SAM) METHOD\n\n## 9.1 Computing the SAM accessibility\n\n\\\nThe code chunk below calculates Hansen’s accessibility using `ac()` of **SpatialAcc** and `data.frame()` is used to save the output in a data frame called `acc_SAM`. Notice that `SAM` is used for \"family\" argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- tbl_df(acc_SAM)\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n\n## 9.2 Visualizing SAM's Accessibility\n\nThe code chunk below uses a collection of mapping functions of the ***tmap*** package to create a high cartographic quality accessibility to eldercare centers in Singapore. Again, as is in the previous sections, `mapex` is reused for the ***bbox*** argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n## 9.3 Statistical Graphic Visualization\n\nNow, we will compare the distribution of SAM accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the `hexagon_SAM` simple feature data frame using the code snippet below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n\n\nNext, `ggplot()` will be used to plot the distribution by using boxplots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}