---
title: "Hands-on Exercise 2 - Part 2: 2nd Order Spatial Point Patterns Analysis Methods"
author: "Lorielle Malveda"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
---

# 1. OVERVIEW

This is the 1st of 2 Hands-on Exercise devoted to Spatial Point Pattern Analysis.

***Spatial Point Pattern Analysis*** is the evalutation of any pattern or distribution of a set of points on a surface. These points can represent locations of various events like crimes, traffic accidents, and disease outbreaks, or they could indicate business services such as coffee shops and fast food outlets, as well as facilities like childcare and eldercare centers.

In this Hands-on Exercise, we will use relevant functions from the ***spatstat*** (for more info, click [here](https://cran.r-project.org/web/packages/spatstat/)) package to explore the spatial distribution of childcare centers in Singapore.

Specifically, this exercise aims to answer the following questions:

-   Are childcare centers in Singapore *randomly distributed* across the country?

-   If they are not, then where are the *areas with a higher concentration* of childcare centers?

# 2. GETTING STARTED

## 2.1 Acquire Data

The following datasets will be used:

-   `CHILDCARE` in geojson format (from data.gov.sg)

    -   a *point feature data* providing both location and attribute information of childcare centers.

-   `MP14_SUBZONE_WEB_PL` in ESRI shapefile format (from data.gov.sg)

    -   a *polygon feature data* providing information of the URA 2014 Master Plan Planning Subzone boundary data.

-   `CostalOutline` in ESRI shapefile format (from SLA)

    -   a *polygon feature data* showing the national boundary of Singapore.

## 2.2 Install and Launch R Packages

```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse)
```

This code chunk uses `p_load()` of the ***pacman*** package (stands for Package Manager) to check if the following packages are installed:

-   [**sf**](https://r-spatial.github.io/sf/): designed to import, manage, and process vector-based geospatial data in R.

-   [**spatstat**](https://spatstat.org/): useful for point pattern analysis. We will use this to perform 1st- and 2nd-order Spatial Point Patterns Analysis and to derive the Kernel Density Estimation (KDE) layer.

-   [**raster**](https://cran.r-project.org/web/packages/raster/): reads, writes, manipulates, analyzes, and model gridded spatial data (i.e. raster). We will use this to convert image outputs generated by ***spatstat*** into ***raster*** format.

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html): provides tools for manipulating geographic data. We will mainly use this to convert Spatial objects into the ***ppp*** format required by ***spatstat***.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html): you must now be familiar with this as we have used this in the previous Hands-on Exercises. This provides functions for cartographic quality static point patterns or interactive maps by using the [Leaflet](https://leafletjs.com/) API.

If available, the packages will then be launched into R.

# 3. SPATIAL DATA WRANGLING

## 3.1 Importing the Spatial Data

To import the datasets, `st_read()` of the ***sf*** package will be used.

```{r}
childcare_sf <- st_read("data/data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "data/data", layer="CostalOutline")
```

```{r}
mpsz_sf <- st_read(dsn = "data/data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

Before proceeding to analysis, let us check first if they are all in the same projection system. **Do not forget to do this! :)**

REVIEW: Using the ***sf*** function we learned before, we will retrieve the referencing system information of the geospatial data.

```{r}
st_crs(childcare_sf)
```

```{r}
st_crs(sg_sf)
```

```{r}
st_crs(mpsz_sf)
```

Notice that except for ***childcare_sf***, ***mpsz_sf*** and ***sg_sf*** do not have proper crs information.

REVIEW: Remember what was discussed in Lesson 2 and assign the correct crs to the 2 datasets.

```{r}
mpsz_sf3414 <- st_transform(mpsz_sf, 
                              crs = 3414)
```

```{r}
sg_sf3414 <- st_transform(sg_sf, 
                              crs = 3414)
```

Checking!

```{r}
st_crs(mpsz_sf3414)
```

```{r}
st_crs(sg_sf3414)
```

There is no need to change the referencing system as it is already at the Singapore National Projected Coordinate System.

## 3.2 Mapping the Geospatial Datasets

After verifying the coordinate reference system for each geospatial dataset, it is also helpful to create a map to visualize their spatial patterns.

Review: Use the mapping techniques learned prior to this exercise, and create a map.

```{r}
tmap_mode("plot")

tm_shape(mpsz_sf3414) +  
  tm_polygons(col = "lightgrey") +
  tm_shape(childcare_sf) + 
  tm_dots()
```

This code sets the ***tmap*** mode to "`plot`" for static map visualization. It then creates a map where the `mpsz_sf3414` polygon layer is displayed with light grey polygons, and the `childcare_sf` point layer is overlaid as dots to show the locations of childcare centers.

Notice that all the geospatial layers fit within the same map extent. This shows that their referencing system and coordinate values are within a common spatial context.

Alternatively, we can also prepare a more interactive map by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

At the interactive mode, ***tmap*** uses Leaflet for R's API. With an interactive map, you can freely navigate and zoom in and out of the map. It also adds to the experience of exploring!

Additionally, you can change the map's background layer. Currently, three internet map layers are provided. They are `ESRI.WorldGrayCanvas`, `OpenStreetMap`, and `ESRI.WorldTopoMap.` The default is `ESRI.WorldGrayCanvas`.

```{r}
 tmap_mode('plot')
```

***Reminder!*** Always remember to switch back to plot mode after the interactive map.

Interactive mode uses a connection, and you should avoid displaying too many interactive maps (no more than 10) in a single RMarkdown document when publishing on Netlify.

# 4. GEOSPATIAL DATA WRANGLING

Although simple feature data frames are becoming increasingly popular compared to ***sp’s Spatial\**** classes, many geospatial analysis packages still require input data in ***sp’s Spatial\**** format. In this section, we are going to convert a simple feature data frame to ***sp’s Spatial\**** class.

## 4.1 **Converting from *sf* format into *spatstat’s ppp* format**

The code chunk below uses the `ppp()` function of the ***spatstat*** package to convert spatial data to ***spatstat's ppp*** object format.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
childcare_ppp
```

Now, let us plot `childcare_ppp` and examine the difference.

```{r}
plot(childcare_ppp)
```

Let us also take a look at the summary statistics to get an overview/feel of how the data is like.

```{r}
summary(childcare_ppp)
```

## 4.2 Handling duplicated points

Here is how we check for duplicates in a ***ppp*** object:

```{r}
any(duplicated(childcare_ppp))
```

Seems there are no duplicates. We will then use the `multiplicity()` function to count the number of co-incidence points. According to rdocumentation.org, the function is intended to count the number of duplicates of each element of an object.

```{r}
multiplicity(childcare_ppp)
```

To check how many locations have more than one-point event:

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

The output shows that there are 128 duplicated point events. To view the locations of the duplicate point events, we will plot `childcare` data by using the code chunk below.

```{r}
tmap_mode('view')
tm_shape(childcare_sf) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

Do not forget to put `tmap_mode` back to '`plot`'! :)

```{r}
tmap_mode('plot')
```

How to spot the duplicate points from the map shown above?

Check the interactive map carefully. The ***darker shaded points*** are those that are overlapping.

Treating Duplicates:

Resolving duplicates can be approached in three ways.

1.  The simplest method is to ***delete the duplicates***, though this would result in a loss of someway of valuable point events.
2.  Apply ***jittering***, which introduces slight variations to the duplicate points, preventing them from occupying the same exact position.
3.  Make each point ***"unique"*** and then attaching the duplicate points as marks or attributes. This requires using analytical techniques that account for these marks.

The code chunk below implements the ***jittering*** approach.

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Checking for the new dataset where the ***jittering*** approach has been used:

```{r}
any(duplicated(childcare_ppp_jit))
```

```{r}
multiplicity(childcare_ppp_jit)
```

```{r}
sum(multiplicity(childcare_ppp_jit) > 1)
```

## 4.3 Creating owin object

When analyzing spatial point patterns, it is recommended to limit the analysis to a specific geographical area, for example, the boundaries of Singapore. An object called ***owin*** under the ***spatstat*** package is specifically designed to represent this polygonal region.

The code snippet below shows how to convert the ***sgSpatialPolygon*** object into an ***owin*** object in ***spatstat***.

```{r}
sg_owin <- as.owin(sg_sf)
```

Use the `plot()` function to display the output object.

```{r}
plot(sg_owin)
```

and `summary()` function of Base R.

```{r}
summary(sg_owin)
```

## 4.4 Combining point events object and owin object.

We are now at the last step of geospatial data wrangling! Check out the code below to extract childcare events that are located within Singapore.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

The output object combined both the point and polygon feature in one ppp object class as shown below.

```{r}
summary(childcareSG_ppp)
```

Let us now plot the derived ***childcareSG_ppp***.

```{r}
plot(childcareSG_ppp)
```

### EXTRACTING STUDY AREA

Let us extract the target planning areas.

```{r}
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

Let us next plot the planning areas for better visualization

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
```

Visualizing each planning area:

```{r}
plot(tm, main = "Tampines")
```

```{r}
plot(ck, main = "Choa Chu Kang")
```

```{r}
plot(jw, main = "Jurong West")
```

### CONVERTING OF sf OBJECTS INTO *owin* OBJECTS

Now, we will convert these ***sf*** objects into ***owin*** objects that is required by ***spatstat***.

```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

### COMBINING CHILDCARE POINTS AND THE STUDY AREA

Next, we will extract the childcare centers that are within the specific region for better analysis later on.

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Let's use the `rescale()` function to transform the unit of measurement from meter to kilometer.

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

Plot the study areas and locations of the childcare centers using the code chunk below.

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

Voila!

# 5. SECOND-ORDER SPATIAL PATTERNS ANALYSIS

## 5.1 Analyzing Spatial Point Process Using the G-Function

The ***G-function*** measures the distribution of the distances from an arbitrary event to its nearest event.

In this section, we are using:

-   `Gest()` of the ***spatstat*** package to compute the G-Function Estimation

-   `envelope()` of the ***spatstat*** package to perform Monte Carlo Simulation Tests.

### **CHOA CHU KANG PLANNING AREA**

#### Computing the G-Function Estimation

The code chunk below computes the G-Function Estimation:

```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

#### Performing Complete Spatial Randomness Test

We will conduct a hypothesis test to confirm the observed spatial patterns above.

**H~o~ = *The distribution of childcare services in Choa Chu Kang is randomly distributed.***

**H~1~= *The distribution of childcare services in Choa Chu Kang is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

**Monte Carlo Test:**

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

```{r}
plot(G_CK.csr)
```

### TAMPINES PLANNING AREA

We are doing the same process but for the Tampines Planning Area this time.

#### Computing G-Function Estimation

```{r}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

#### Performing Complete Spatial Randomness Test

**H~o~ = *The distribution of childcare services in Tampines is randomly distributed.***

**H~1~= *The distribution of childcare services in Tampines is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

```{r}
plot(G_tm.csr)
```

## 5.2 Analyzing Spatial Point Process Using F-Function

The F-Function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape.

In this section, we are using:

-   `Fest()` of the ***spatstat*** package to compute the G-Function Estimation

-   `envelope()` of the ***spatstat*** package to perform Monte Carlo Simulation Tests.

### **CHOA CHU KANG PLANNING AREA**

#### Computing F-Function Estimation

The code chunk below computes the F-Function Estimation:

```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

#### Performing Complete Spatial Randomness Test

We will conduct a hypothesis test to confirm the observed spatial patterns above.

**H~o~ = *The distribution of childcare services in Choa Chu Kang is randomly distributed.***

**H~1~= *The distribution of childcare services in Choa Chu Kang is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

**Monte Carlo Test:**

```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

```{r}
plot(F_CK.csr)
```

### TAMPINES PLANNING AREA

#### Computing F-Function Estimation

```{r}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

#### Performing Complete Spatial Randomness Test

**H~o~ = *The distribution of childcare services in Tampines is randomly distributed.***

**H~1~= *The distribution of childcare services in Tampines is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

```{r}
plot(F_tm.csr)
```

## 5.3 Analyzing Spatial Point Process Using K-Function

The K-Function measures the number of events found up to a given distance of any particular event.

In this section, we are using:

-   `Kest()` of the ***spatstat*** package to compute the G-Function Estimation

-   `envelope()` of the ***spatstat*** package to perform Monte Carlo Simulation Tests.

### **CHOA CHU KANG PLANNING AREA**

#### Computing K-Function Estimation

Observe that we are following the same process as the previous sections, just with a different estimation function.

```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

#### Performing Complete Spatial Randomness Test

We will conduct a hypothesis test to confirm the observed spatial patterns above.

**H~o~ = *The distribution of childcare services in Choa Chu Kang is randomly distributed.***

**H~1~= *The distribution of childcare services in Choa Chu Kang is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### TAMPINES PLANNING AREA

#### Computing K-Function Estimation

```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### Performing Complete Spatial Randomness Test

We will conduct a hypothesis test to confirm the observed spatial patterns above.

**H~o~ = *The distribution of childcare services in Tampines is randomly distributed.***

**H~1~= *The distribution of childcare services in Tampines is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

## 5.4 Analyzing Spatial Point Process Using L-Function

When I try to research on what exactly the purpose of L-Function is, it will usually just say that even mathematicians cannot come up with an exact definition of the function.

In this section, we are using:

-   `Lest()` of the ***spatstat*** package to compute the G-Function Estimation

-   `envelope()` of the ***spatstat*** package to perform Monte Carlo Simulation Tests.

### **CHOA CHU KANG PLANNING AREA**

#### Computing L-Function Estimation

```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

#### Performing Complete Spatial Randomness Test

We will conduct a hypothesis test to confirm the observed spatial patterns above.

**H~o~ = *The distribution of childcare services in Choa Chu Kang is randomly distributed.***

**H~1~= *The distribution of childcare services in Choa Chu Kang is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

**Monte Carlo Test:**

```{r}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

### TAMPINES PLANNING AREA

#### Computing L-Function Estimation

```{r}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### Performing Complete Spatial Randomness Test

We will conduct a hypothesis test to confirm the observed spatial patterns above.

**H~o~ = *The distribution of childcare services in Tampines is randomly distributed.***

**H~1~= *The distribution of childcare services in Tampines is not randomly distributed.***

The null hypothesis will be rejected if the p-value is smaller than alpha value of 0.001.

**Monte Carlo Test:**

```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

Then, plot the model output by using the code chunk below.

```{r}
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
