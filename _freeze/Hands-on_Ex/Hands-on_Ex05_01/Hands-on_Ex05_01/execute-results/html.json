{
  "hash": "edebb55a7e3813b40c5a4ef16fc9ff30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 5 - Part 1: Global Measures of Spatial Autocorrelation\"\nauthor: \"Lorielle Malveda\"\ndate: \"September 23, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n---\n\n\n\n# 1. OVERVIEW\n\nThis exercise will tackle Global Measures of Spatial Autocorrelation (GMSA) by using the ***spdep*** package.\n\nBy the end to this hands-on exercise, you will be able to:\n\n-   import geospatial data using appropriate function(s) of ***sf*** package,\n\n-   import csv file using appropriate function of ***readr*** package,\n\n-   perform relational join using appropriate join function of ***dplyr*** package,\n\n-   **compute Global Spatial Autocorrelation (GSA) statistics by using appropriate functions of *spdep* package,**\n\n    -   **plot Moran scatterplots, and**\n\n    -   **compute and plot spatial correlograms using appropriate functions of the *spdep* package.**\n\n-   **provide statistically correct interpretation of GSA statistics.**\n\n# 2. GETTING STARTED\n\n## 2.1 Objective - The Analytical Question\n\nIn spatial policy, a key development goal for local governments and planners is to ensure an equal distribution of development across the province.\n\nThe objective of this study is to apply appropriate spatial statistical methods to determine whether development is distributed geographically. If it is not, the next step is to investigate whether there is evidence of spatial clustering. If clustering is present, we will then seek to identify the locations of these clusters.\n\nIn this case study, we focus on analyzing the spatial pattern of a specific development indicator—GDP per capita—in Hunan Province, People's Republic of China.\n\n## 2.2 Study Area and Dataset\n\nTwo data sets will be used in this hands-on exercise, which are:\n\n1.  **Hunan Province Administrative Boundary Layer (at County Level).** This is a geospatial data set in ESRI shapefile format.\n2.  **Hunan_2012.csv.** This csv file contains selected Hunan’s local development indicators in 2012.\n\n## 2.3 Setting the Analytical Tools\n\nThis code chunk uses `p_load()` of the ***pacman*** package (stands for Package Manager) to check if the following packages are installed:\n\n**sf:** used for importing and handling geospatial data in R.\n\n**tidyverse:** mainly used for wrangling attribute data in R.\n\n***spdep:*** used to compute spatial weights, global and local spatial autocorrelation statistics.\n\n**tmap:** used to prepare cartographic quality chropleth map.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, dplyr)\n```\n:::\n\n\n\nIf available, the packages will then be launched into R.\n\n# 3. GETTING THE DATA INTO R ENVIRONMENT\n\n**Datasets:**\n\n-   ***Hunan County Boundary Layer:*** geospatial data set in the ESRI shapefile format.\n\n-   ***Hunan_2012.csv:*** aspatial data which contains selected Hunan’s local development indicators in 2012.\n\n## 3.1 Importing *shapefile* into the R Environment\n\nLet us use the ***sf*** package to import the Hunan shapefile into R.\n\nThe output is a simple features ***sf*** object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\loriellemalveda\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex05_01\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\n## 3.2 Importing *csv* into the R Environment\n\nNext, we will import `Hunan_2012.csv` into R by using the `read_csv` function of the ***readr*** package.\n\nThe output is R dataframe class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\n\n## 3.3 Performing Relational Join\n\nThe following code chunk updates the attribute table of the `hunan` SpatialPolygonsDataFrame by merging it with the attribute fields of the `hunan2012` dataframe. This is accomplished using the `left_join()` function from the `dplyr` package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>%\n  dplyr::select(1:4, 7, 15)\n```\n:::\n\n\n\n## 3.4 Visualizing the Regional Development Indicator\n\nNext, we'll prepare a basemap and a choropleth map to display the distribution of GDP per capita for 2012, using the `qtm()` function from the `tmap` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_01_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n# 4. GLOBAL MEASURES OF SPATIAL AUTOCORRELATION\n\nIn this section, you will learn how **to compute global spatial autocorrelation statistics and to perform spatial complete randomness test for global spatial autocorrelation.**\n\n## 4.1 Computing Contiguity Spatial Weights\n\nBefore we can compute the global spatial autocorrelation statistics, we need to construct **a spatial weights matrix f**or the study area. This matrix defines the neighborhood relationships between the geographical units (e.g., counties) in the study area.\n\nIn the code below, the `poly2nb()` function from the `spdep` package is used to compute contiguity weight matrices. This function creates a neighbors list based on regions that share contiguous boundaries. According to the documentation, you can specify the \"queen\" argument, which takes either `TRUE` or `FALSE`. If you do not specify this argument, the default is `TRUE`, meaning that the function will return a list of first-order neighbors based on the Queen contiguity criteria unless you explicitly set `queen = FALSE`.\n\nThe following code chunk specifically computes the Queen contiguity weight matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbors. There are two area units with only one neighbor.\n\n## 4.2 Row-standardized Weights Matrix\n\nNext, we need to assign weights to each neighboring polygon. In our case, we will assign equal weights to each neighboring polygon (style = \"W\"). This is done by assigning the fraction 1 / (# of neighbors) to each neighboring county and then summing the weighted values, such as income. **While this method is intuitive, it has a potential drawback: polygons located at the edges of the study area will have fewer neighbors, which could lead to over- or under-estimating the true extent of spatial autocorrelation in the data.**\n\nFor simplicity, we will use the style = \"W\" option in this example. However, it’s worth noting that other more robust options are available, such as style = \"B\", which might address some of these limitations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n\nThe code chunk above demonstrates the use of the `nb2listw()` function, which converts a neighbors list object of class `nb` into a spatial weights list. There are two key arguments in this function: `style` and `zero.policy`.\n\n-   The input of [`nb2listw()`](https://r-spatial.github.io/spdep/reference/nb2listw.html) must be an object of class **nb**. The syntax of the function has two major arguments, namely style and zero.poly.\n\n-   *style* can take values “W”, “B”, “C”, “U”, “minmax” and “S”. B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\n\n-   If *zero policy* is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %\\*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n\n# 5. GLOBAL MEASURES OF SPATIAL AUTOCORRELATION: MORAN'S I\n\nIn this section, you will learn how to perform Moran’s I statistics testing by using `moran.test()` of ***spdep***.\n\n## 5.1 Maron's I Test\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n\n> Since the Moran I Statistic is at \\~0,300, we can say that it has positive weak autocorrelation. Meaning values of the GDPPC are clustered together, whether high or low, geographically speaking.\n>\n> Since the p-value is less than 0.05, we have statistical evidence to reject the null hypothesis. Meaning, there is strong evidence of spatial autocorrelation in the GDPPC data for the Hunan province.\n\n## 5.2 Computing Monte Carlo Moran's I\n\nThe code chunk below performs permutation test for Moran’s I statistic by using `moran.mc()` of ***spdep***. A total of 1000 simulations (999+1) will be performed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n> A p-value of 0.001 indicates strong evidence against the null hypothesis, suggesting that the observed spatial pattern is very unlikely to have occurred by chance (spatial randomness).\n>\n> There is significant positive spatial autocorrelation in GDPPC, and this autocorrelation is not likely to be due to spatial randomness. The significant Moran's I value, supported by the high rank and low p-value in the Monte-Carlo simulation, strongly suggests that similar economic conditions are geographically clustered in the province.\n\n## 5.3 Visualizing Monte Carlo Moran's I\n\nIt is always a good practice for us the examine the simulated Moran’s I test statistics in greater detail. This can be achieved by plotting the distribution of the statistical values as a histogram by using the code chunk below.\n\nIn the code chunk below [`hist()`](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist) and [`abline()`](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/abline) of R Graphics are used.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01504572\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.004371574\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_01_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n> The histogram shows the distribution of the Monte Carlo Simulation results. It looks somehow normally distributed but also a bit right-skewed.\n\n> Challenge:\n>\n> USING GGPLOT - need to convert to dataframe first to use the ***ggplot*** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(bperm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 7\n $ statistic  : Named num 0.301\n  ..- attr(*, \"names\")= chr \"statistic\"\n $ parameter  : Named num 1000\n  ..- attr(*, \"names\")= chr \"observed rank\"\n $ p.value    : num 0.001\n $ alternative: chr \"greater\"\n $ method     : chr \"Monte-Carlo simulation of Moran I\"\n $ data.name  : chr \"hunan$GDPPC \\nweights: rswm_q  \\nnumber of simulations + 1: 1000 \\n\"\n $ res        : num [1:1000] 0.05798 0.09954 0.06943 -0.10422 0.00381 ...\n - attr(*, \"class\")= chr [1:2] \"htest\" \"mc.sim\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndata_for_plot <- data.frame(bperm$res)\nggplot(data = data_for_plot, aes(x = bperm.res)) +\n  geom_histogram(bins = 30, fill = \"grey\", color = \"black\") +\n  labs(title = \"Histogram of Simulated Moran's I\",\n       x = \"Simulated Moran's I\",\n       y = \"Frequency\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_01_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n# 6. GLOBAL MEASURES OF SPATIAL AUTOCORRELATION: GEARY'S C\n\nIn this section, you will learn how to perform **Geary’s C statistics** **testing** by using appropriate functions of the ***spdep*** package.\n\n## 6.1 Geary's C Test\n\nThe code chunk below performs Geary’s C test for spatial autocorrelation by using `geary.test()` of ***spdep***.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n\n\n:::\n:::\n\n\n\n> The statistic is less than 1, which means there is positive spatial autocorrelation. This indicates that neighboring areas tend to have similar GDPPC values more than would be expected if the spatial distribution were random.\n>\n> The p-value is extremely low, which provides strong evidence against the null hypothesis of no spatial autocorrelation. It indicates that the probability of observing a Geary C statistic as extreme as 0.6907223 under the null hypothesis is very small (about 0.01526%).\n\n## 6.2 Computing Monte Carlo Geary’s C\n\nThe code chunk below performs permutation test for Geary’s C statistic by using `geary.mc()` of ***spdep***.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n> According to the simulation, there is significant positive spatial autocorrelation initially indicated by the test.\n>\n> The p-value suggests there is evidence that the geographical distribution of GDPPC across Hunan Province is not random but exhibits significant spatial clustering, where economically similar regions are close to each other.\n\n## 6.3 Visualizing the Monte Carlo Geary's C\n\nNext, we will plot a histogram to reveal the distribution of the simulated values by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.004402\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007436493\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_01_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n> Question: What statistical observation can you draw from the output?\n>\n> Same was the output for Moran's I. Slightly right-skewed but overall resembles a normal distribution (bell curve).\n\n# **7. SPATIAL CORRELOGRAM**\n\nSpatial Correlograms are tools for analyzing patterns of spatial autocorrelation in data or model residuals. They illustrate the relationship between the correlation of spatial data pairs and the increasing distance or lag between them, plotting an index of autocorrelation, such as Moran’s I or Geary’s C, against distance.\n\nWhile not as foundational as variograms, which are central to geostatistics, spatial correlograms serve as valuable exploratory and descriptive tools. In fact, they often offer more detailed information than variograms for these purposes.\n\n## 7.1 Compute Moran’s I correlogram\n\nIn the code chunk below, [`sp.correlogram()`](https://r-spatial.github.io/spdep/reference/sp.correlogram.html) of the ***spdep*** package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used is Moran’s I.\n\nThe **plot()** of base Graph is then used to plot the output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_01_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nPlotting the output might not allow us to provide complete interpretation. This is because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results as in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\n> The significant positive autocorrelation at closer lags suggests that economic conditions or policies might have effects that diminish with distance, and planning or interventions might need to consider these local spatial dependencies to be effective.\n\n## **7.2 Compute Geary’s C Correlogram and Plot**\n\nIn the code chunk below, `sp.correlogram()` of **spdep** package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Geary’s C. The **plot()** of base Graph is then used to plot the output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_01_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nSimilar to the previous step, we will print out the analysis report by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex05_01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}